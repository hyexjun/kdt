# -*- coding: utf-8 -*-
"""exam09_principles_of_learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IsYZW11g0AifXyLV8DqmfOE3autigXaY
"""

import numpy as np
import matplotlib.pyplot as plt

class add_graph:
    def __init__(self):
        pass
    def forward(self, x, y):
        out = x + y
        return out
    def backward(self, dout):
        dx = 1 * dout
        dy = 1 * dout
        return dx, dy

class mul_graph:
    def __init__(self):
        self.x = None
        self.y = None
    def forward(self, x, y):
        self.x = x
        self.y = y
        out = x * y
        return out
    def backward(self, dout):
        dx = self.y * dout
        dy = self.x * dout
        return dx, dy

class mse_graph:
    def __init__(self):
        self.loss = None
        self.y = None
        self.t = None
        self.x = None
    def forward(self, y, t):
        self.t = t
        self.y = y
        self.loss = np.square(self.t - self.y
                              ).sum() / self.t.shape[0]
        return self.loss
    def backward(self, x, dout=1):
        data_size = self.t.shape[0]
        dweight_mse = ((self.y - self.t) * x).sum() * 2 / data_size
        dbias_mse = (self.y - self.t).sum() * 2 / data_size
        return dweight_mse, dbias_mse

apple = 100
apple_num = 2
orange = 150
orange_num = 3
tax = 1.1

mul_apple_graph = mul_graph()
mul_orange_graph = mul_graph()
add_apple_orange_graph = add_graph()
mul_tax_graph = mul_graph()

apple_price = mul_apple_graph.forward(apple, apple_num)
orange_price = mul_orange_graph.forward(orange, orange_num)
all_price = add_apple_orange_graph.forward(apple_price, orange_price)
total_price = mul_tax_graph.forward(all_price, tax)
print(total_price)

dprice = 1
dall_price, dtax = mul_tax_graph.backward(dprice)
dapple_price, dorange_price = \
    add_apple_orange_graph.backward(dall_price)
dorange, dorange_num = mul_orange_graph.backward(
    dorange_price)
dapple, dapple_num = mul_apple_graph.backward(
    dapple_price)
print('dApple', dapple)
print('dApple_num', dapple_num)
print('dOrange', dorange)
print('dOrange_num', dorange_num)

def celsius_to_fahrenheit(x):
    return x * 1.8 + 32

data_C = np.array(range(100))
data_F = celsius_to_fahrenheit(data_C)
scaled_data_C = data_C / 100
scaled_data_F = data_F / 100
print(scaled_data_C)
print(scaled_data_F)

weight = np.random.uniform(0, 5, 1)
print(weight)
bias = 0

weight_graph = mul_graph()
bias_graph = add_graph()

weighted_data = weight_graph.forward(
    weight, scaled_data_C)
predict_data = bias_graph.forward(
    weighted_data, bias)
print(predict_data)

dout = 1
dbias, dbiased_data = bias_graph.backward(dout)
dweight, dscaled_data_C = weight_graph.backward(
    dbiased_data)
print(dbias)
print(dweight)

mseGraph = mse_graph()
mse = mseGraph.forward(predict_data, scaled_data_F)
print(mse)

weight_mse_gradient, bias_mse_gradient = \
    mseGraph.backward(scaled_data_C)
print(weight_mse_gradient)
print(bias_mse_gradient)

learning_rate = 0.1
learned_weight = weight - learning_rate * \
            weight_mse_gradient * np.average(dweight)
print('before learnig weight :', weight)
print('after learning weight :', learned_weight)

learned_bias = bias - learning_rate * bias_mse_gradient * dbias
print('before learning bias :', bias)
print('after learning bias :', learned_bias)

weight = np.random.uniform(0, 5, 1)
bias = 0
dout = 1
learning_rate = 0.1
error_list = []
for i in range(1000):
    #forward
    weighted_data = weight_graph.forward(
        weight, scaled_data_C)
    predict_data = bias_graph.forward(  
        weighted_data, bias)
    #backward
    dout = 1
    dbias, dbiased_data = bias_graph.backward(dout)
    dweight, dscaled_data_C = weight_graph.backward(
        dbiased_data)
    #mse
    mse = mseGraph.forward(predict_data, scaled_data_F)
    error_list.append(mse)
    weight_mse_gradient, bias_mse_gradient = \
    mseGraph.backward(scaled_data_C)
    #learning
    weight = weight - learning_rate * \
            weight_mse_gradient * np.average(dweight)
    bias = bias - learning_rate * bias_mse_gradient * dbias
print(weight)
print(bias)

print(error_list[-1])

plt.plot(error_list)
plt.show()